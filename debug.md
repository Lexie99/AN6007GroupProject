For api.py：
1. query功能里，meter ID输错没有提示; 现在网页一进去就默认展示00000001数据；点击select time period返回的结果错误，有时候没有变化，不知道是什么原因
2. register功能里，invalid or register meter ID提示后，前面已经填好的内容是不是要清除掉；不知道为啥老跳过3
3. stop server期间，meter reading出错，这些数据还没想好怎么处理
4. 将一些功能模块化成Class，规范及简化代码，比如说：

        在一个中等规模的项目中，有几个核心部分特别适合通过类来模块化，这样可以使代码更加清晰、易于维护，并减少重复逻辑：

        1. **业务实体（Domain Entities）**  
        - **User 类**  
            - **作用**：封装用户的各项属性（如 meter_id、region、area、dwelling_type 等），以及与用户相关的验证逻辑和数据转换（例如转换为字典便于存储或序列化）。  
            - **好处**：将与用户相关的逻辑集中在一个地方，避免在各个 API 中重复编写验证和格式化代码，同时也方便单元测试用户相关功能。
        - **MeterReading 类**  
            - **作用**：封装单个电表读数的数据（例如时间戳、读数值），提供验证、格式转换、统计计算等方法。  
            - **好处**：使得处理单条读数记录的逻辑独立出来，当需要进行数据导出、汇总或统计时，可以直接调用类中的方法，而不必重复解析或转换数据。

        2. **数据存储和管理**  
        - **DataStore 类**  
            - **作用**：集中管理用户数据、读数数据等的加载、存储和更新逻辑。  
            - **好处**：通过集中化的数据访问层，可以更容易地替换底层存储（例如从 JSON 文件迁移到数据库），同时减少各个 API 中直接读写文件的重复代码。

        3. **调度和维护管理**  
        - **MaintenanceManager 或 Scheduler 类**  
            - **作用**：封装定时任务、维护模式的启用/关闭逻辑（例如每天 00:00 进入维护模式、01:00 退出维护模式，或者执行数据备份任务）。  
            - **好处**：使得维护相关的定时任务逻辑和状态管理独立于具体的 API 逻辑，不仅提高了代码组织性，也方便将来扩展更多调度任务或维护功能。

        4. **配置管理**  
        - **Config 类**  
            - **作用**：将所有配置信息（如从 JSON 文件加载的配置、数据库连接参数、API 地址等）封装到一个类中，并提供统一的访问接口。  
            - **好处**：这样可以在应用启动时统一加载配置，避免在多个模块中重复解析配置文件，同时也方便在不同环境下切换不同的配置。


For dash_app.py:
1. 基础URL可以写进config里，现在这样看起来有点傻